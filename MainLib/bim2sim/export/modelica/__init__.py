"""Package for Modelica export"""

import os
import logging

import codecs
from mako.template import Template

from bim2sim.ifc2python import element as elem

TEMPLATEPATH = os.path.join(os.path.dirname(__file__), 'tmplModel.txt')
# prevent mako newline bug by reading file seperatly
with open(TEMPLATEPATH) as f:
    templateStr = f.read()
templ = Template(templateStr)

class Model():
    """Modelica model"""

    def __init__(self, name, comment, instances: list, connections: dict):

        self.logger = logging.getLogger(__name__)

        self.name = name
        self.comment = comment
        self.instances = instances
        self.connections = connections

    def code(self):
        """returns Modelica code"""
        return templ.render(model=self)

    def save(self, path: str):
        """Save model as Modelica file"""
        _path = os.path.normpath(path)
        if os.path.isdir(_path):
            _path = os.path.join(_path, self.name)

        if not path.endswith(".mo"):
            _path += ".mo"

        data = self.code()

        self.logger.info("Saving '%s' to '%s'", self.name, _path)
        with codecs.open(_path, "w", "utf-8") as file:
            file.write(data)


class Instance():
    """Modelica model instance"""

    library = None
    version = None
    path = None
    represents = None
    lookup = {}
    dummy = None

    def __init__(self, name, params: dict, comment=None):

        self.name = name
        self.comment = comment
        self.params = params

    @staticmethod
    def _lookup_add(key, value):
        """Adds key and value to Instance.lookup. Returns conflict"""
        if key in Instance.lookup:
            logger.error("Conflicting representations (%s) in '%s' and '%s'", \
                key, value.__name__, Instance.lookup[key].__name__)
            return True
        else:
            Instance.lookup[key] = value
            return False

    @staticmethod
    def _init_factory():
        """initialize lookup for factory"""
        logger = logging.getLogger(__name__)
        conflict = False

        for library in Instance.__subclasses__():
            if library.library:
                logger.info("Found library '%s'", library.library)
            elif library.__name__ == "Dummy":
                Instance.dummy = library
                continue
            else:
                logger.error("Library not defined for '%s'", library.__name__)
                raise AssertionError("Library not defined")
            for cls in library.__subclasses__():
                if cls.represents is None:
                    logger.warning("'%s' represents no model and can't be used", cls.__name__)
                    continue

                if isinstance(cls.represents, (list, set)):
                    for rep in cls.represents:
                        confl = Instance._lookup_add(rep, cls)
                        if confl: conflict = True
                else:
                    confl = Instance._lookup_add(cls.represents, cls)
                    if confl: conflict = True

        if conflict:
            raise AssertionError("Conflict(s) in Models. (See log for details).")

        logger.debug("Modelica librarys intitialized with %d models:", len(Instance.lookup))
        for inst in set(Instance.lookup.values()):
            logger.debug("- %s", inst.__name__)

    @staticmethod
    def factory(element):
        """Create model depending on ifc_element"""

        if not Instance.lookup:
            Instance._init_factory()

        cls = Instance.lookup.get(element.__class__, Instance.dummy)

        name = element.__class__.__name__.lower()
        guid = getattr(element, "guid", "").replace("$", "_")
        if guid:
            name = name + "_" + guid
        params = cls.get_params(element)
        comment = cls.get_comment(element)

        return cls(name, params=params, comment=comment)

    @classmethod
    def get_params(cls, ele):
        return {}

    @classmethod
    def get_comment(cls, ele):
        return ele.name
        #return "Autogenerated by BIM2SIM"

    @property
    def path(self):
        return self.__class__.path

    def __repr__(self):
        return "<%s %s>"%(self.path, self.name)


class Dummy(Instance):
    path = "Path.to.Dummy"
    represents = elem.Dummy

if __name__ == "__main__":

    class Radiator(Instance):
        path = "Heating.Consumers.Radiators.Radiator"

    par = {
        "redeclare package Medium" : "Modelica.Media.Water.ConstantPropertyLiquidWater",
        "Q_flow_nominal" : 4e3,
        "n" : 1.3,
        "Type" : "HKESim.Heating.Consumers.Radiators.BaseClasses.ThermostaticRadiatorValves.Types.radiatorCalculationTypes.proportional",
        "k" : 1.5
    }

    conns = {"radiator1.port_a": "radiator2.port_b"}

    inst1 = Instance("radiator1", {})
    inst2 = Instance("radiator2", par)

    model = Model("System", "Test", [inst1, inst2], conns)

    print(model.code())
    #model.save(r"C:\Entwicklung\temp")
